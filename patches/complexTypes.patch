--- SOAP-Lite-0.69
/lib/SOAP/Lite.pm	2006-12-05 10:47:09.000000000 -0500
+++ /usr/lib/perl5/vendor_perl/5.8.8/SOAP/Lite.pm.with_my_patch	2006-12-11 13:28:53.000000000 -0500
@@ -2789,11 +2789,77 @@
   }

 }
 
+## This is part of a patch used to help create complex data types.

+## the created data structure is written out using stubmaker.pl
+sub get_complex_data_types {
+  my $s = shift;
+  my $data_types;

+  foreach my $schema ($s->types->schema)
+  {
+    ## loop through each complex data type

+    foreach my $value ($schema->complexType)
+    {
+      #{
+        ## ArrayOfstring falls into this category.  

+        foreach my $complex_content ($value->complexContent)
+        {

+          ## we get the data type (e.g. SOAP-ENC:Array) of this complexType
+          foreach my $restriction ($complex_content->restriction)

+          {
+            my $restriction_type = $restriction->base;

+            $data_types->{$value->name}->{restriction_type} = $restriction_type->value;
+            foreach my $sequence ($restriction->sequence)

+            {
+              my @elements;

+              foreach my $element ($sequence->element)
+              {
+                ## we use this string to create the individual soap::data objects in the stub

+                my $soap_data_string =  "SOAP::Data->name('".$element->name."')->type('".$element->type."')->attr({";

+                $soap_data_string .= do { my %attr = %{$element->attr};

+                                   join(', ', map {"'$_' => '$attr{$_}'"}
+                                   grep {/^xmlns:(?!-)/}

+                                   keys %attr)

+                                   };
+                $soap_data_string .= "})";
+                push(@elements,$soap_data_string);
+              }

+              $data_types->{$value->name}->{elements} = \@elements;

+            }
+          }
+        }
+        ## we have a complex object but it's content is simple, so lets break it down into it's sequences

+        foreach my $sequence ($value->sequence)

+        {
+          ## now we break each sequence down into it's individual elements
+          my @elements;
+          foreach my $element ($sequence->element)

+          {
+            my $soap_data_string = "SOAP::Data->name('".$element->name."')->type('".$element->type."')->attr({";

+            $soap_data_string .= do { my %attr = %{$element->attr};

+                                   join(', ', map {"'$_' => '$attr{$_}'"}
+                                   grep {/^xmlns:(?!-)/}

+                                   keys %attr)

+                                   };
+            $soap_data_string .= "})";
+            push(@elements,$soap_data_string);
+          }
+          $data_types->{$value->name}->{elements} = \@elements;


+        }
+    }
+  }
+  return $data_types;
+}
+
 sub parse {
+  ## self = SOAP::Schema::WSDL
+  ## $s = SOAP::Custom::XML::Data
   my $self = shift->new;
   my($s, $service, $port) = @_;


   my @result;
 
+  # get a list of the complex data types
+  my $data_types = get_complex_data_types($s); 
+
   # handle imports
   $self->import($s);
 
@@ -2808,7 +2874,6 @@
   </service>


 </definitions>
 FAKE
-
   my $has_warned = 0;
   foreach (@services) {
     my $name = $_->name;
@@ -2839,18 +2904,23 @@
               my $inputmessage = SOAP::Utils::disqualify($_->input->message);


               foreach my $msg ($s->message) {
                 next unless $msg->name eq $inputmessage;
-                if ($invocationStyle eq "document" && $encodingStyle eq "literal") {


-#                  warn "document/literal support is EXPERIMENTAL in SOAP::Lite"
-#		      if !$has_warned && ($has_warned = 1);
+                if ($invocationStyle eq "document" && $encodingStyle eq "literal") 


+                {
+                  #warn "document/literal support is EXPERIMENTAL in SOAP::Lite"
+                  #if !$has_warned && ($has_warned = 1);
                   my ($input_ns,$input_name) = SOAP::Utils::splitqname($msg->part->element);


-                  foreach my $schema ($s->types->schema) {
-                    foreach my $element ($schema->element) {
+                  foreach my $schema ($s->types->schema) 
+                  {


+                    foreach my $element ($schema->element) 
+                    {
                       next unless $element->name eq $input_name;
                       push @parts,parse_schema_element($element);


                     }
 		    $services{$opername}->{parameters} = [ @parts ];
                   }
-                } else {
+                } 
+                else 
+                {
                   # TODO - support all combinations of doc|rpc/lit|enc.


                   #warn "$invocationStyle/$encodingStyle is not supported in this version of SOAP::Lite";
                   @parts = $msg->part;
@@ -2870,6 +2940,13 @@
         }
       }


     }
+    # add the data_types into the services hash
+    # to be passed into generate_stub                  
+    ## TODO I dont like adding the data_types into the services hash
+    ## but I don't know who else calls this method and I don't want to 


+    ## change the retuned value;
+    $services{data_types} = $data_types;
+    
     # fix nonallowed characters in package name, and add 's' if started with digit
     for ($name) { s/\W+/_/g; s/^(\d)/s$1/ } 


     push @result, $name => \%services;
@@ -2985,7 +3062,7 @@
   my $package = shift;
   my $services = $self->services->{$package};
   my $schema_url = $self->schema_url;
-
+  my $data_types = $services->{data_types};


   $self->{'_stub'} = <<"EOP";
 package $package;
 # Generated by SOAP::Lite (v$SOAP::Lite::VERSION) for Perl -- 
soaplite.com
@@ -2993,8 +3070,28 @@

 # -- generated at [@{[scalar localtime]}]
 EOP
   $self->{'_stub'} .= "# -- generated from $schema_url\n" if $schema_url;
+  $self->{'_stub'} .= 'my %soap_data_objects = ('."\n";


+  foreach my $object (sort keys %$data_types)
+  {
+    $self->{'_stub'} .= "  $object" .' => {'."\n";
+    if($data_types->{$object}->{restriction_type})

+    {

+      $self->{'_stub'} .= "      restriction_type => '".$data_types->{$object}->{restriction_type}."',\n";
+    }
+    $self->{'_stub'} .= "      elements => [\n";


+    foreach my $element (@{$data_types->{$object}->{elements}})
+    {
+      $self->{'_stub'} .= "        $element,\n";
+    }
+    $self->{'_stub'} .= "      ],\n";


+    $self->{'_stub'} .= "  },\n";
+  }
+  $self->{'_stub'} .= ");\n";
+
+      
   $self->{'_stub'} .= 'my %methods = ('."\n";


   foreach my $service (keys %$services) {
+    next if $service eq 'data_types';
     $self->{'_stub'} .= "$service => {\n";
     foreach (qw(endpoint soapaction namespace)) {


       $self->{'_stub'} .= "    $_ => '".$services->{$service}{$_}."',\n";
@@ -3002,7 +3099,31 @@
     $self->{'_stub'} .= "    parameters => [\n";


     foreach (@{$services->{$service}{parameters}}) {
 #      next unless $_;
-      $self->{'_stub'} .= "      SOAP::Data->new(name => '".$_->name."', type => '".$_->type."', attr => {";


+      $self->{'_stub'} .= "      SOAP::Data->name('".$_->name."'";
+      if(ref $_->value)
+      {
+        $self->{'_stub'} .= "=> \\SOAP::Data->value(";


+        foreach my $object ($_->element)
+        {
+          $self->{'_stub'} .= "\n          SOAP::Data->name('".$object->name."')->type('".$object->type."')->attr({";


+          $self->{'_stub'} .= do { my %attr = %{$object->attr};
+                                   join(', ', map {"'$_' => '$attr{$_}'"}
+                                   grep {/^xmlns:(?!-)/}


+                                   keys %attr)
+                                   };
+          $self->{'_stub'} .= "}),";
+                               
+        }
+        $self->{'stub'} .= ")->type('".$_->type."')->attr({";


+        $self->{'_stub'} .= do { my %attr = %{$_->attr};
+                                 join(', ', map {"'$_' => '$attr{$_}'"}
+                                 grep {/^xmlns:(?!-)/}


+                                 keys %attr)
+                                };
+        $self->{'_stub'} .= "),\n";
+
+      }
+      $self->{'_stub'} .=  ")->type('".$_->type."')->attr({";


       $self->{'_stub'} .= do { my %attr = %{$_->attr}; 
                                join(', ', map {"'$_' => '$attr{$_}'"} 
                                           grep {/^xmlns:(?!-)/}


@@ -3025,6 +3146,70 @@
 @EXPORT_OK = (keys %methods);
 %EXPORT_TAGS = ('all' => [@EXPORT_OK]);
 
+sub fill_template {
+  my $template = shift;
+  my $typename = shift;
+  my $param = shift;


+  ## restriction_type indicates that this is a complexContent type
+  if(exists $soap_data_objects{$typename}->{restriction_type})
+  {
+    my @elements;
+    my ($soap_enc,$restriction) = split(/:/,$soap_data_objects{$typename}->{restriction_type});


+    ## check to make sure we're getting the proper data structure for the data type;
+    #die "Expecting an $restriction but got ".ref $param if(uc(ref $param) ne uc $restriction);
+    ## loop through the elemtents of the complexType data structure


+    foreach my $element (@{$soap_data_objects{$typename}->{elements}})
+    {
+      ## get the object type to pass into the next iteration of the function
+      my ($prefix,$typename) = SOAP::Utils::splitqname($element->type);


+      if(ref($param) eq 'ARRAY')
+      {
+        ## each item of the parameter will become a new soap::data object
+        ## based on $element
+        foreach my $item (@{$param})
+        {


+          my $object_for_array = SOAP::Data->new(name => $element->name, type => $element->type, attr => $element->attr);
+          my $test = fill_template($object_for_array,$typename,$item);


+          push(@elements,$test);
+        }
+      }
+    }
+    $template->value(\@elements);
+  }
+  ## this is a complexData type, but not nested to create complexContent
+  ## these element must take a hash ref, I think.  I don't think arrays would fall under


+  ## this category.  TODO check this
+  elsif(exists $soap_data_objects{$typename}->{elements})
+  {
+    die "Expecing a hash ref but got ".ref $param unless(ref $param eq 'HASH');

+    my @elements;

+    foreach my $element (@{$soap_data_objects{$typename}->{elements}})
+    {
+      my ($prefix,$typename) = SOAP::Utils::splitqname($element->type);
+      my $object_for_array = SOAP::Data->new(name => $element->name, type => $element->type, attr => $element->attr);


+      $object_for_array = fill_template($object_for_array,$typename,$param->{$element->name});
+      push(@elements,$object_for_array);
+    }
+    ## Is this correct? without this type declaration soap lite 


+    ## tries to use SOAP-ENC:ArrayType.  The code below makes a soap lite
+    ## server read the parameters in as an hash instead of a array
+    my $object_string;
+    foreach my $item (0 .. @elements)


+    {
+        $object_string .= '$elements['."$item".'],';
+    }
+    chop($object_string);
+    my $temp_element = SOAP::Data->name($template->name => \SOAP::Data->value(eval $object_string))->type($template->type)->attr($template->attr);


+    $template = $temp_element;
+  }
+  ## this must be a primitive type (e.g. string, int)
+  else
+  {
+    $template->value($param);
+  }
+  return $template;
+}
+
 sub _call {

   my ($self, $method) = (shift, shift);

   my $name = UNIVERSAL::isa($method => 'SOAP::Data') ? $method->name : $method;
@@ -3037,10 +3222,8 @@
     if (@templates) {
       my $template = shift @templates;

       my ($prefix,$typename) = SOAP::Utils::splitqname($template->type);

-      my $method = 'as_'.$typename;
-      # TODO - if can('as_'.$typename) {...}
-      my $result = $self->serializer->$method($param, $template->name, $template->type, $template->attr);


-      push(@parameters, $template->value($result->[2]));
+      my $template = fill_template($template,$typename,$param);
+      push(@parameters, $template);
     } else {
       push(@parameters, $param);


     }
@@ -3093,6 +3276,16 @@
   die "Unrecognized method '$method'. List of available method(s): @EXPORT_OK\n";
 }
 
+#define Authentication
+#sub SOAP::Transport::HTTP::Client::get_basic_credentials {


+#    ## username and password for the api
+#    my $USER = '';
+#    my $PASS = '';
+#    return $USER => $PASS;
+#}
+
+
+
 1;
 EOP
   return $self->stub;
