<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>SOAP::SOM - provides access to the values contained in SOAP Response</title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;SOAP::SOM - provides access to the values contained in SOAP Response</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#methods">METHODS</a></li>
	<li><a href="#examples">EXAMPLES</a></li>
	<ul>

		<li><a href="#accessing_element_values">ACCESSING ELEMENT VALUES</a></li>
		<li><a href="#accessing_attribute_values">ACCESSING ATTRIBUTE VALUES</a></li>
		<li><a href="#iterating_over_an_array">ITERATING OVER AN ARRAY</a></li>
		<li><a href="#detecting_a_soap_fault">DETECTING A SOAP FAULT</a></li>
		<li><a href="#parsing_arrays_of_arrays">PARSING ARRAYS OF ARRAYS</a></li>
	</ul>

	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#acknowledgements">ACKNOWLEDGEMENTS</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
	<li><a href="#authors">AUTHORS</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>SOAP::SOM - provides access to the values contained in SOAP Response</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Objects from the SOAP::SOM class aren't generally instantiated directly by an application. Rather, they are handed back by the deserialization of a message. In other words, developers will almost never do this:</p>
<pre>
    $som = SOAP::SOM-&gt;new;</pre>
<p>SOAP::SOM objects are returned by a SOAP::Lite call in a client context. For example:</p>
<pre>
    my $client = SOAP::Lite
        -&gt;readable(1)
        -&gt;uri($NS)
        -&gt;proxy($HOST)
    $som = $client-&gt;someMethod();</pre>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="item_new"><code>new(message)</code></a></strong>

<dd>
<pre>
    $som = SOAP::SOM-&gt;new($message_as_xml);</pre>
</dd>
<dd>
<p>As said, the need to actually create an object of this class should be very rare. However, if the need arises, the syntax must be followed. The single argument to new must be a valid XML document the parser will understand as a SOAP response.</p>
</dd>
</dl>
<p>The following group of methods provide general data retrieval from the SOAP::SOM object. The model for this is an abbreviated form of XPath. Following this group are methods that are geared towards specific retrieval of commonly requested elements.</p>
<dl>
<dt><strong><a name="item_match"><code>match(path)</code></a></strong>

<dd>
<pre>
    $som-&gt;match('/Envelope/Body/[1]');</pre>
</dd>
<dd>
<p>This method sets the internal pointers within the data structure so that the retrieval methods that follow will have access to the desired data. In the example path, the match is being made against the method entity, which is the first child tag of the body in a SOAP response. The enumeration of container children starts at 1 in this syntax, not 0. The returned value is dependent on the context of the call. If the call is made in a boolean context (such as <code>if ($som-&gt;match($path))</code>), the return value is a boolean indicating whether the requested path matched at all. Otherwise, an object reference is returned. The returned object is also a SOAP::SOM instance but is smaller, containing the subset of the document tree matched by the expression.</p>
</dd>
<dt><strong><a name="item_valueof"><code>valueof(node)</code></a></strong>

<dd>
<pre>
    $res = $som-&gt;valueof('[1]');</pre>
</dd>
<dd>
<p>When the SOAP::SOM object has matched a path internally with the match method, this method allows retrieval of the data within any of the matched nodes. The data comes back as native Perl data, not a class instance (see dataof). In a scalar context, this method returns just the first element from a matched node set. In an array context, all elements are returned. Assuming that the earlier call happens after the earlier call to match, it retrieves the result entity from the method response that is contained in <code>$som</code>, as this is the first child element in a method-response tag.</p>
</dd>
<dt><strong><a name="item_dataof"><code>dataof(node)</code></a></strong>

<dd>
<pre>
    $resobj = $som-&gt;dataof('[1]');</pre>
</dd>
<dd>
<p>Performs the same operation as the earlier valueof method, except that the data is left in its <a href="../../../site/lib/SOAP/Data.html">the SOAP::Data manpage</a> form, rather than being deserialized. This allows full access to all the attributes that were serialized along with the data, such as namespace and encoding.</p>
</dd>
<dt><strong><a name="item_headerof"><code>headerof(node)</code></a></strong>

<dd>
<pre>
    $resobj = $som-&gt;headerof('[1]');</pre>
</dd>
<dd>
<p>Acts much like dataof, except that it returns an object of the <a href="../../../site/lib/SOAP/Header.html">the SOAP::Header manpage</a> class (covered later in this chapter), rather than SOAP::Data. This is the preferred interface for manipulating the header entities in a message.</p>
</dd>
<dt><strong><a name="item_namespaceuriof"><code>namespaceuriof(node)</code></a></strong>

<dd>
<pre>
    $ns = $som-&gt;namespaceof('[1]');</pre>
</dd>
<dd>
<p>Retrieves the namespace URI that governs the requested node. Note that namespaces are inherited, so this method will return the relevant value, even if it derives from a parent or other ancestor node.</p>
</dd>
</dl>
<p>The following methods provide more direct access to the message envelope. All these methods return some form of a Perl value, most often a hash reference, when called. Context is also relevant: in a scalar context only the first matching node is returned, while in an array context, all matching nodes are. When called as a static method or as a regular function (such as <code>SOAP::SOM::envelope</code>), any of the following methods returns the XPath string that is used with the match method to retrieve the data.</p>
<dl>
<dt><strong><a name="item_root">root</a></strong>

<dd>
<pre>
    $root = $som-&gt;root;</pre>
</dd>
<dd>
<p>Returns the value of the root element as a hash reference. It behaves exactly as <code>$som-</code>valueof('/')&gt; does.</p>
</dd>
<dt><strong><a name="item_envelope">envelope</a></strong>

<dd>
<pre>
    $envelope = $som-&gt;envelope;</pre>
</dd>
<dd>
<p>Retrieves the ``Envelope'' element of the message, returning it and its data as a hash reference. Keys in the hash will be Header and Body (plus any optional elements that may be present in a SOAP 1.1 envelope), whose values will be the serialized header and body, respectively.</p>
</dd>
<dt><strong><a name="item_header">header</a></strong>

<dd>
<pre>
    $header = $som-&gt;header;</pre>
</dd>
<dd>
<p>Retrieves the header portion of the envelope as a hash reference. All data within it will have been deserialized. If the attributes of the header are desired, the static form of the method can be combined with match to fetch the header as a SOAP::Data object:</p>
</dd>
<dd>
<pre>
    $header = $som-&gt;match(SOAP::SOM::header)-&gt;dataof;</pre>
</dd>
<dt><strong><a name="item_headers">headers</a></strong>

<dd>
<pre>
    @hdrs = $som-&gt;headers;</pre>
</dd>
<dd>
<p>Retrieves the node set of values with deserialized headers from within the Header container. This is different from the earlier header method in that it returns the whole header as a single structure, and this returns the child elements as an array. In other words, the following expressions yield the same data structure:</p>
</dd>
<dd>
<pre>
    $header = ($som-&gt;headers)[0];
    $header = $som-&gt;valueof(SOAP::SOM::header.'/[1]');</pre>
</dd>
<dt><strong><a name="item_body">body</a></strong>

<dd>
<pre>
    $body = $som-&gt;body;</pre>
</dd>
<dd>
<p>Retrieves the message body as a hash reference. The entity tags act as keys, with their deserialized content providing the values.</p>
</dd>
<dt><strong><a name="item_fault">fault</a></strong>

<dd>
<pre>
    if ($som-&gt;fault) { die $som-&gt;fault-&gt;faultstring }</pre>
</dd>
<dd>
<p>Acts both as a boolean test whether a fault occurred, and as a way to retrieve the Fault entity itself from the message body as a hash reference. If the message contains a fault, the next four methods (faultcode, faultstring, faultactor, and faultdetail) may be used to retrieve the respective parts of the fault (which are also available on the hash reference as keys). If fault in a boolean context is true, the <a href="#item_result"><code>result</code></a>, <a href="#item_paramsin"><code>paramsin</code></a>, <a href="#item_paramsout"><code>paramsout</code></a>, and <a href="#item_method"><code>method</code></a> methods all return <code>undef</code>.</p>
</dd>
<dt><strong><a name="item_faultcode">faultcode</a></strong>

<dd>
<pre>
    $code = $som-&gt;faultcode;</pre>
</dd>
<dd>
<p>Returns the faultcode element of the fault if there is a fault; undef otherwise.</p>
</dd>
<dt><strong><a name="item_faultstring">faultstring</a></strong>

<dd>
<pre>
    $string = $som-&gt;faultstring;</pre>
</dd>
<dd>
<p>Returns the faultstring element of the fault if there is a fault; undef otherwise.</p>
</dd>
<dt><strong><a name="item_faultactor">faultactor</a></strong>

<dd>
<pre>
    $actor = $som-&gt;faultactor;</pre>
</dd>
<dd>
<p>Returns the faultactor element of the fault, if there is a fault and if the actor was specified within it. The faultactor element is optional in the serialization of a fault, so it may not always be present. This element is usually a string.</p>
</dd>
<dt><strong><a name="item_faultdetail">faultdetail</a></strong>

<dd>
<pre>
    $detail = $som-&gt;faultdetail;</pre>
</dd>
<dd>
<p>Returns the content of the detail element of the fault, if there is a fault and if the detail element was provided. Note that the name of the element isn't the same as the method, due to the possibility for confusion had the method been called simply, detail. As with the faultactor element, this isn't always a required component of a fault, so it isn't guaranteed to be present. The specification for the detail portion of a fault calls for it to contain a series of element tags, so the application may expect a hash reference as a return value when detail information is available (and undef otherwise).</p>
</dd>
<dt><strong><a name="item_method">method</a></strong>

<dd>
<pre>
    $method = $som-&gt;method</pre>
</dd>
<dd>
<p>Retrieves the ``method'' element of the message, as a hash reference. This includes all input parameters when called on a request message or all result/output parameters when called on a response message. If there is a fault present in the message, it returns undef.</p>
</dd>
<dt><strong><a name="item_result">result</a></strong>

<dd>
<pre>
    $value = $som-&gt;result;</pre>
</dd>
<dd>
<p>Returns the value that is the result of a SOAP response. The value will be already deserialized into a native Perl datatype.</p>
</dd>
<dt><strong><a name="item_paramsin">paramsin</a></strong>

<dd>
<pre>
    @list = $som-&gt;paramsin;</pre>
</dd>
<dd>
<p>Retrieves the parameters being passed in on a SOAP request. If called in a scalar context, the first parameter is returned. When called in a list context, the full list of all parameters is returned. Each parameter is a hash reference, following the established structure for such return values.</p>
</dd>
<dt><strong><a name="item_paramsout">paramsout</a></strong>

<dd>
<pre>
    @list = $som-&gt;paramsout;</pre>
</dd>
<dd>
<p>Returns the output parameters from a SOAP response. These are the named parameters that are returned in addition to the explicit response entity itself. It shares the same scalar/list context behavior as the paramsin method.</p>
</dd>
<dt><strong><a name="item_paramsall">paramsall</a></strong>

<dd>
<pre>
    @list = $som-&gt;paramsall;</pre>
</dd>
<dd>
<p>Returns all parameters from a SOAP response, including the result entity itself, as one array.</p>
</dd>
<dt><strong><a name="item_parts"><code>parts()</code></a></strong>

<dd>
<p>Return an array of <code>MIME::Entity</code>'s if the current payload contains attachments, or returns undefined if payload is not MIME multipart.</p>
</dd>
</li>
<dt><strong><a name="item_is_multipart"><code>is_multipart()</code></a></strong>

<dd>
<p>Returns true if payload is MIME multipart, false otherwise.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<p>
</p>
<h2><a name="accessing_element_values">ACCESSING ELEMENT VALUES</a></h2>
<p>Suppose for the following SOAP Envelope:</p>
<pre>
    &lt;Envelope&gt;
      &lt;Body&gt;
        &lt;fooResponse&gt;
          &lt;bar&gt;abcd&lt;/bar&gt;
        &lt;/fooResponse&gt;
      &lt;/Body&gt;
    &lt;/Envelope&gt;</pre>
<p>And suppose you wanted to access the value of the bar element, then use the following code:</p>
<pre>
    my $soap = SOAP::Lite
        -&gt;uri($SOME_NS)
        -&gt;proxy($SOME_HOST);
    my $som = $soap-&gt;foo();
    print $som-&gt;valueof('//fooResponse/bar');</pre>
<p>
</p>
<h2><a name="accessing_attribute_values">ACCESSING ATTRIBUTE VALUES</a></h2>
<p>Suppose the following SOAP Envelope:</p>
<pre>
    &lt;Envelope&gt;
      &lt;Body&gt;
        &lt;c2fResponse&gt;
          &lt;convertedTemp test=&quot;foo&quot;&gt;98.6&lt;/convertedTemp&gt;
        &lt;/c2fResponse&gt;
      &lt;/Body&gt;
    &lt;/Envelope&gt;</pre>
<p>Then to print the attribute 'test' use the following code:</p>
<pre>
    print &quot;The attribute is: &quot; . 
      $som-&gt;dataof('//c2fResponse/convertedTemp')-&gt;attr-&gt;{'test'};</pre>
<p>
</p>
<h2><a name="iterating_over_an_array">ITERATING OVER AN ARRAY</a></h2>
<p>Suppose for the following SOAP Envelope:</p>
<pre>
    &lt;Envelope&gt;
      &lt;Body&gt;
        &lt;catalog&gt;
          &lt;product&gt;
            &lt;title&gt;Programming Web Service with Perl&lt;/title&gt;
            &lt;price&gt;$29.95&lt;/price&gt; 
          &lt;/product&gt;
          &lt;product&gt;
            &lt;title&gt;Perl Cookbook&lt;/title&gt;
            &lt;price&gt;$49.95&lt;/price&gt; 
          &lt;/product&gt;
        &lt;/catalog&gt;
      &lt;/Body&gt;
    &lt;/Envelope&gt;</pre>
<p>If the SOAP Envelope returned contained an array, use the following code to iterate over the array:</p>
<pre>
    for my $t ($som-&gt;valueof('//catalog/product')) {
      print $t-&gt;{title} . &quot; - &quot; . $t-&gt;{price} . &quot;\n&quot;;
    }</pre>
<p>
</p>
<h2><a name="detecting_a_soap_fault">DETECTING A SOAP FAULT</a></h2>
<p>A SOAP::SOM object is returned by a SOAP::Lite client regardless of whether the call succeeded or not. Therefore, a SOAP Client is responsible for determining if the returned value is a fault or not. To do so, use the <a href="#item_fault"><code>fault()</code></a> method which returns 1 if the SOAP::SOM object is a fault and 0 otherwise.</p>
<pre>
    my $som = $client-&gt;someMethod(@parameters);</pre>
<pre>
    if ($som-&gt;fault) {
      print $som-&gt;faultdetail;
    } else {
      # do something
    }</pre>
<p>
</p>
<h2><a name="parsing_arrays_of_arrays">PARSING ARRAYS OF ARRAYS</a></h2>
<p>The most efficient way To parse and to extract data out of an array containing another array encoded in a SOAP::SOM object is the following:</p>
<pre>
    $xml = &lt;&lt;END_XML;
    &lt;foo&gt;
      &lt;person&gt;
        &lt;foo&gt;123&lt;/foo&gt;
        &lt;foo&gt;456&lt;/foo&gt;
      &lt;/person&gt;
      &lt;person&gt;
        &lt;foo&gt;789&lt;/foo&gt;
        &lt;foo&gt;012&lt;/foo&gt;
      &lt;/person&gt;
    &lt;/foo&gt;
    END_XML</pre>
<pre>
    my $som = SOAP::Deserializer-&gt;deserialize($xml);
    my $i = 0;
    foreach my $a ($som-&gt;dataof(&quot;//person/*&quot;)) {
        $i++;
        my $j = 0;
        foreach my $b ($som-&gt;dataof(&quot;//person/[$i]/*&quot;)) {
            $j++;
            # do something
        }
    }</pre>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="../../../site/lib/SOAP/Data.html">the SOAP::Data manpage</a>, <a href="../../../site/lib/SOAP/Serializer.html">the SOAP::Serializer manpage</a></p>
<p>
</p>
<hr />
<h1><a name="acknowledgements">ACKNOWLEDGEMENTS</a></h1>
<p>Special thanks to O'Reilly publishing which has graciously allowed SOAP::Lite to republish and redistribute large excerpts from <em>Programming Web Services with Perl</em>, mainly the SOAP::Lite reference found in Appendix B.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright (C) 2000-2004 Paul Kulchenko. All rights reserved.</p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>
<p>
</p>
<hr />
<h1><a name="authors">AUTHORS</a></h1>
<p>Paul Kulchenko (<a href="mailto:paulclinger@yahoo.com">paulclinger@yahoo.com</a>)</p>
<p>Randy J. Ray (<a href="mailto:rjray@blackperl.com">rjray@blackperl.com</a>)</p>
<p>Byrne Reese (<a href="mailto:byrne@majordojo.com">byrne@majordojo.com</a>)</p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;SOAP::SOM - provides access to the values contained in SOAP Response</span></strong></big>
</td></tr>
</table>

</body>

</html>
